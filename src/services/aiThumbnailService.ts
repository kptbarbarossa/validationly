import { ThumbnailDesign, HookType, VideoTone, VideoGoal } from '../types';

interface ThumbnailGenerationRequest {
  hookText: string;
  hookType: HookType;
  category: string;
  tone: VideoTone;
  goal: VideoGoal;
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
}

interface HuggingFaceResponse {
  blob(): Promise<Blob>;
  ok: boolean;
  status: number;
}

export class AIThumbnailService {
  private readonly GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
  private readonly HUGGINGFACE_API_URL = 'https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-schnell';

  /**
   * Generate AI-powered thumbnail with Gemini + Hugging Face
   */
  async generateThumbnail(request: ThumbnailGenerationRequest): Promise<ThumbnailDesign> {
    try {
      // Step 1: Use Gemini to optimize the thumbnail prompt
      const optimizedPrompt = await this.optimizePromptWithGemini(request);
      
      // Step 2: Generate image with Hugging Face
      const imageUrl = await this.generateImageWithHuggingFace(optimizedPrompt);
      
      // Step 3: Create thumbnail design object
      const design = this.createThumbnailDesign(request, optimizedPrompt, imageUrl);
      
      return design;
      
    } catch (error) {
      console.error('AI Thumbnail Generation Error:', error);
      
      // Fallback to mock design if AI fails
      return this.createFallbackDesign(request);
    }
  }

  /**
   * Use Gemini to optimize thumbnail prompt for better performance
   */
  private async optimizePromptWithGemini(request: ThumbnailGenerationRequest): Promise<string> {
    const geminiApiKey = process.env.GOOGLE_GENAI_API_KEY;
    
    if (!geminiApiKey) {
      throw new Error('Gemini API key not configured');
    }

    const systemPrompt = `You are an expert YouTube thumbnail designer. Create a detailed, professional prompt for AI image generation that will maximize CTR (click-through rate) and retention.

RULES:
- Focus on high-contrast, eye-catching visuals
- Include specific facial expressions and emotions
- Specify exact text overlays and positioning
- Mention optimal colors for mobile viewing
- Include professional photography terms
- Keep text readable on mobile devices
- Ensure brand safety

Hook Type: ${request.hookType}
Category: ${request.category}
Tone: ${request.tone}
Goal: ${request.goal}
Hook Text: "${request.hookText}"

Generate a detailed prompt for FLUX/Stable Diffusion that will create a high-performing YouTube thumbnail. Focus on visual elements, not explanations.`;

    const response = await fetch(`${this.GEMINI_API_URL}?key=${geminiApiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: systemPrompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topP: 0.8,
          maxOutputTokens: 1024,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data: GeminiResponse = await response.json();
    const optimizedPrompt = data.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!optimizedPrompt) {
      throw new Error('No prompt generated by Gemini');
    }

    console.log('ðŸ¤– Gemini optimized prompt:', optimizedPrompt);
    return optimizedPrompt;
  }

  /**
   * Generate image using Hugging Face FLUX model
   */
  private async generateImageWithHuggingFace(prompt: string): Promise<string> {
    const huggingfaceApiKey = process.env.HUGGINGFACE_API_KEY;
    
    if (!huggingfaceApiKey) {
      throw new Error('Hugging Face API key not configured');
    }

    // Add YouTube thumbnail specifications to prompt
    const enhancedPrompt = `${prompt}, YouTube thumbnail, 1280x720 resolution, high quality, professional, eye-catching, optimized for mobile viewing, sharp details, vibrant colors`;

    const response = await fetch(this.HUGGINGFACE_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${huggingfaceApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        inputs: enhancedPrompt,
        parameters: {
          width: 1280,
          height: 720,
          num_inference_steps: 4, // Fast generation with FLUX Schnell
          guidance_scale: 3.5,
        }
      })
    });

    if (!response.ok) {
      // If model is loading, wait and retry
      if (response.status === 503) {
        console.log('â³ Hugging Face model loading, waiting...');
        await new Promise(resolve => setTimeout(resolve, 10000));
        return this.generateImageWithHuggingFace(prompt);
      }
      throw new Error(`Hugging Face API error: ${response.status}`);
    }

    // Convert response to blob and create data URL
    const imageBlob = await response.blob();
    const imageUrl = await this.blobToDataUrl(imageBlob);
    
    console.log('ðŸŽ¨ Hugging Face image generated successfully');
    return imageUrl;
  }

  /**
   * Convert blob to data URL for display
   */
  private async blobToDataUrl(blob: Blob): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  /**
   * Create structured thumbnail design object
   */
  private createThumbnailDesign(
    request: ThumbnailGenerationRequest, 
    prompt: string, 
    imageUrl: string
  ): ThumbnailDesign {
    const mainText = request.hookText.split(' ').slice(0, 3).join(' ').toUpperCase();
    const style = this.selectOptimalStyle(request.hookType, request.goal);
    
    return {
      id: `ai_thumb_${Date.now()}`,
      prompt,
      generated_url: imageUrl,
      style,
      elements: {
        main_text: mainText,
        face_expression: this.getFaceExpression(request.hookType),
        background_theme: this.getBackgroundTheme(request.category),
        color_scheme: this.getColorScheme(request.tone),
        overlay_effects: this.getOverlayEffects(style)
      },
      performance_prediction: this.predictPerformance(request, style)
    };
  }

  /**
   * Create fallback design if AI generation fails
   */
  private createFallbackDesign(request: ThumbnailGenerationRequest): ThumbnailDesign {
    const mainText = request.hookText.split(' ').slice(0, 3).join(' ').toUpperCase();
    const style = this.selectOptimalStyle(request.hookType, request.goal);
    
    const fallbackPrompt = `Professional YouTube thumbnail for ${request.category}, ${style} style, featuring "${mainText}" text overlay, ${request.tone} tone, optimized for ${request.goal}`;
    
    return {
      id: `fallback_thumb_${Date.now()}`,
      prompt: fallbackPrompt,
      style,
      elements: {
        main_text: mainText,
        face_expression: this.getFaceExpression(request.hookType),
        background_theme: this.getBackgroundTheme(request.category),
        color_scheme: this.getColorScheme(request.tone),
        overlay_effects: this.getOverlayEffects(style)
      },
      performance_prediction: this.predictPerformance(request, style)
    };
  }

  // Helper methods
  private selectOptimalStyle(hookType: HookType, goal: VideoGoal): ThumbnailDesign['style'] {
    const styleMap: Record<HookType, ThumbnailDesign['style']> = {
      'question': 'question_mark',
      'bold_claim': 'bold_text',
      'curiosity_gap': 'split_screen',
      'pattern_interrupt': 'face_reaction',
      'fomo': 'countdown',
      'challenge': 'before_after',
      'authority': 'bold_text',
      'contrarian': 'face_reaction'
    };
    
    return styleMap[hookType] || 'bold_text';
  }

  private getFaceExpression(hookType: HookType): string {
    const expressions: Record<HookType, string> = {
      'question': 'confused, curious, raised eyebrow',
      'bold_claim': 'confident, determined, pointing',
      'curiosity_gap': 'surprised, intrigued, wide eyes',
      'pattern_interrupt': 'shocked, amazed, mouth open',
      'fomo': 'urgent, worried, checking time',
      'challenge': 'determined, focused, intense',
      'authority': 'professional, confident, expert',
      'contrarian': 'skeptical, challenging, smirking'
    };
    
    return expressions[hookType] || 'confident, engaging';
  }

  private getBackgroundTheme(category: string): string {
    const themes: Record<string, string> = {
      'fitness': 'modern gym, workout equipment, athletic environment',
      'tech': 'sleek office, computer screens, modern workspace',
      'business': 'professional office, charts, corporate setting',
      'education': 'classroom, books, learning materials',
      'lifestyle': 'home environment, daily activities, personal space',
      'food': 'kitchen, ingredients, cooking setup',
      'travel': 'destinations, maps, adventure gear'
    };
    
    return themes[category.toLowerCase()] || `${category} related professional environment`;
  }

  private getColorScheme(tone: VideoTone): string {
    const schemes: Record<VideoTone, string> = {
      'energetic': 'bright red, electric blue, neon yellow, high contrast',
      'analytical': 'deep blue, clean white, accent green, professional',
      'casual': 'warm orange, friendly blue, natural green, approachable',
      'authoritative': 'navy blue, gold accents, clean white, premium',
      'friendly': 'soft blue, warm yellow, gentle green, welcoming'
    };
    
    return schemes[tone] || 'bright, attention-grabbing colors';
  }

  private getOverlayEffects(style: ThumbnailDesign['style']): string[] {
    const effects: Record<ThumbnailDesign['style'], string[]> = {
      'bold_text': ['large bold text overlay', 'drop shadow', 'contrast outline'],
      'split_screen': ['vertical split line', 'before/after labels', 'comparison arrows'],
      'face_reaction': ['emotion indicators', 'thought bubble', 'reaction emojis'],
      'before_after': ['transformation arrow', 'progress indicator', 'time stamps'],
      'question_mark': ['large question mark', 'curiosity indicators', 'mystery elements'],
      'countdown': ['timer overlay', 'urgency indicators', 'deadline warnings']
    };
    
    return effects[style] || ['attention-grabbing overlay'];
  }

  private predictPerformance(request: ThumbnailGenerationRequest, style: ThumbnailDesign['style']) {
    let ctrScore = 60; // Higher base for AI-generated
    let retentionScore = 55;
    let brandSafety = 85;
    
    // Hook type bonuses
    const hookBonuses: Record<HookType, { ctr: number; retention: number }> = {
      'pattern_interrupt': { ctr: 20, retention: 15 },
      'question': { ctr: 15, retention: 12 },
      'curiosity_gap': { ctr: 18, retention: 10 },
      'bold_claim': { ctr: 12, retention: 8 },
      'fomo': { ctr: 22, retention: 5 },
      'challenge': { ctr: 14, retention: 18 },
      'authority': { ctr: 10, retention: 15 },
      'contrarian': { ctr: 16, retention: 12 }
    };
    
    const bonus = hookBonuses[request.hookType] || { ctr: 8, retention: 8 };
    ctrScore += bonus.ctr;
    retentionScore += bonus.retention;
    
    // AI generation bonus
    ctrScore += 10; // AI-optimized visuals
    retentionScore += 5; // Better visual quality
    
    return {
      ctr_score: Math.min(100, Math.max(0, Math.round(ctrScore))),
      retention_score: Math.min(100, Math.max(0, Math.round(retentionScore))),
      brand_safety: Math.min(100, Math.max(0, Math.round(brandSafety)))
    };
  }
}

export const aiThumbnailService = new AIThumbnailService();
